<?php

// application/models/SparePartPricesMapper.php
//require_once 'SparePartSupplier.php';


class Default_Model_SparePartPricesMapper extends MapperBase
{
	static $prices ;
	static $prices_from_current_supplier;
	static $current_supplier_id;
	
	public function __construct(){
		$this->setDbTable('Default_Model_DbTable_SparePartPrices');
		$this->setUnique_vars(array('SUPPLIER_PART_NUMBER'
					//,'price_inc_vat' // removed until the stuff works with the vat matching.
					,'SPARE_PART_SUPPLIER_ID'));
		if(self::$prices == null){
			self::$prices = array();
		}
		parent::__construct();
	}

	public function verifySparePartSupplierId($sps_id){
		if(empty(self::$prices_from_current_supplier)){
			try{
				$this->fillCacheDirect($sps_id);
				self::$current_supplier_id=$sps_id;
			}
			catch(exception $e){
				die("Exception in mapper ".$e);
			
			}
			return;
		}
		if(self::$current_supplier_id!=$sps_id){
			echo "Now you are chaning the supplier from ".$prices_from_current_supplier.
				" to ".$sps_id;
			self::$prices_from_current_supplier = null;
			$this->verifySparePartSupplierId($sps_id);
		}
	}
	
	static public function existsInCache($lower_attribs,&$spare_part_price_id,&$natual_key){
		$spp_mapper = MapperFactory::getSppMapper();
		$spp_mapper->verifySparePartSupplierId($lower_attribs['spare_part_supplier_id']);
		if(array_key_exists('supplier_part_number',$lower_attribs)){
			$natual_key = $lower_attribs['supplier_part_number'];
		}
		else{error('Attribs did not contain supplier_part_number '.var_dump($lower_attribs));
		}
				
		return 
			is_array(self::$prices_from_current_supplier) 
			&& array_key_exists($natual_key,self::$prices_from_current_supplier);		
	}
	
	/**
	 * 
	 * Enter description here ...
	 * @param unknown_type $attribs
	 * @param unknown_type $spare_part_price_id
	 * @return Default_Model_DbTable_SparePartPrices
	 */
	static public function getOrCreatePrice($attribs,&$spare_part_price_id){
		$natual_key=null;
		$lower_attribs = array_change_key_case($attribs,CASE_LOWER);
		
		if(self::existsInCache($lower_attribs, $spare_part_price_id, $natual_key))
		{
			//Cache hit!
			//echo "<br>cache hit! - $natual_key";
			$spp = self::$prices_from_current_supplier[$natual_key];
			$spare_part_price_id = $spp['spare_part_price_id'];
			$spp['cache']=true; // less memory than 'hit';
			return $spp;
		}
		else{
			//cache miss
			if(Bildelspriser_XmlImport_PriceParser::$_instance->_log_level > 20)
				Bildelspriser_XmlImport_PriceParser::$_instance->log(
				bdp::log("cache miss! - $natual_key ".var_export	($attribs,true)));
			//$da;
			//echo "Dumping cache ".var_export(self::$prices_from_current_supplier,true);
			$new_obj=null;
			try{
				$new_obj = new Default_Model_SparePartPrices($lower_attribs);
				$spare_part_price_id = $new_obj->save();
				isset($spare_part_price_id)
					or error('SparePartPrices was NOT created in '.__FILE__);
				$lower_attribs['spare_part_price_id'] = $spare_part_price_id ;
				self::$prices_from_current_supplier[$natual_key] = $lower_attribs;
				bdp::log('SparePartPrices created with key id='.$spare_part_price_id);
			}catch(exception $e)
			{
				error ("Error $e ");
			}
			return $new_obj;
		}
	}
	
	/**
	 * 
	 * @param $carmake Default_Model_CarMakes
	 * @return unknown_type
	 */
    public function save(Default_Model_SparePartPrices  $spp)
    {
    	global $_SERVER;
         /*	From AutoGeneratedClass
		  * private $_car_make_id=null;
			private $_car_make_name=null;
			private $_car_make_main_id=null;
			private $_created=null;
			private $_created_by=null;
			private $_state=null;
			private $_updated=null;
			private $_updated_by=null;*/
    	if(Bildelspriser_XmlImport_PriceParser::$_price_parser_run_id == null)
    		error("Bildelspriser_XmlImport_PriceParser::price_parser_run_id was null");
    	//bdp::info('Saving spare_price_id = '.$spp->getSpare_part_price_id());
    	$data = array(	    	
			'name' => utf8_encode($spp->name),
			'description' => utf8_encode($spp->description),
			'spare_part_url' => $spp->spare_part_url,
			'spare_part_image_url' => $spp->spare_part_image_url,
			'spare_part_category_id' => $spp->spare_part_category_id,
			'spare_part_category_free_text' => $spp->spare_part_category_free_text,
			'part_placement' =>  $spp->part_placement,
			'part_placement_left_right' => $spp->getPart_placement_left_right(),
			'part_placement_front_back' => $spp->getPart_placement_front_back(),
			'supplier_part_number' => ($spp->supplier_part_number),
			'original_part_number' => $spp->getOriginal_part_number(),
			'price_inc_vat' => $spp->price_inc_vat,
			'producer_make_name' => $spp->getProducer_make_name(),
			'producer_part_number' => $spp->getProducer_part_number(),
			'spare_part_supplier_id' => $spp->getSpare_part_supplier_id(),
			'created_by' => $spp->getCreated_by(),
            'created' 		  => date('Y-m-d H:i:s'),
    		'price_parser_run_id' => Bildelspriser_XmlImport_PriceParser::$_price_parser_run_id
//            'updated' 		  => date('Y-m-d H:i:s')    	
        );  
        $str = implode('<br>',$data);
        if((strpos($str,'Ã') || strpos($str,'Â'))) {
        	die("<h1>Unicode issues</h1>".$str);
        }     
        //$this->PostponeSave($data);
        //return $this->_guid;
        bdp::info('Saving Price with Supplier_part_number =  '.$spp->supplier_part_number);
        if (null === ($id = $spp->getSpare_part_price_id())) {
        	unset($data['spare_part_price_id']);
            $insert_id = null;
			try {
				$insert_id = $this->getDbTable()->insert($data);
			} catch (Exception $e) {
				echo "<hr>Exception when saving data in ".__CLASS__.'->'.__METHOD__." \n<br/>"; 
				echo "<div style='font:8px;' >small<ul>";
				foreach($data as $k=>$p){
					echo "<li><b>$k</b> : $p</li>";
				}
				echo "</ul><font size='2'>";
				echo '<br>'.nl2br($e->__toString()).'</font></div>';
				throw $e;
				return;
			}				
            //echo "<H3>Saving - ".$data['name'].' - '.$data['supplier_part_number'].' - '.$insert_id." <H3/>";
            if(null===$insert_id){
            	throw new Exception("insert(\$data) did not return an insert ID! '$insert_id'  ");
            }
            if($insert_id<0){
            	$info =  "Data you tried to isert was <pre>".nl2br(var_export($data))."</pre>";
            	throw new Exception("insert(\$data) did not return positive number as an insert ID! - '$insert_id' ".$info);
            }
            return $insert_id;
        } else {
        	// NOTE - PERFORMANCE OPTIMIZATION  - 
        	return $spp->getSpare_part_price_id();
        	//TODO: Evaluate dirty flag! Then save. 	 
        	
        	//unset($data['created_by']);		// 
        	//unset($data['created']);        //	
        	//unset($data['car_make_name']);  // it is never possible to change a car_make_name - only its state      	
        	//$data['updated']=date('Y-m-d H:i:s');
        	//$data['updated_by']=date('Y-m-d H:i:s');
        	//$carmake->UpdateToDb(xmlModelHandler::get_DB_SCHEMA());
        	//die('Finally an update - id = ' .$id);
        	/*$pk_name = current($this->getPrimaryKeyName());
        	assertEx(is_string($pk_name),"PK_NAME was empty".var_export($pk_name,true));
        	$pk_value = $spp->getPrimaryKeyValue();
        	assertEx($pk_value && is_scalar($pk_value),"PK_Value was not specified" . var_export($pk_value,true));
        	$ar = array("$pk_name = ?" => $pk_value);
        	//$where_clause = " `$pk_name` =  ".$pk_value;
        	//die(var_export($ar,true)."<hr>".$pk_value);*/
        	$this->getDbTable()->update($data,  $ar);
        	return $pk_value;
        }
        bdp::info('Done saving spare_part_price');
    }

    
    
    public function fetch($select)
    {
    	$resultSet = "";//new Zend_db_
    	//$this->getDbTable()->setFetchMode(Zend_Db::FETCH_ASSOC);
    	try{
        	$resultSet = $this->getDbTable()->fetchAll($select);
        	//print_r($resultSet);
    	}
    	catch(Exception $e){
    		echo "Exception occured '$select' ";
    		var_dump($e,$select);
   		 	echo("End of story");
    	}
    	/* @var unknown_type */
    	$row = $resultSet[0];
    	$entry = new Default_Model_SparePartPrices();
    	//var_dump($row->toArray());
    	$entry->setOptions($row->toArray());
    	 /*foreach ($resultSet as $row) {
            $entry = new Default_Model_CarMakes();
            /* $entry->setId($row->id)
                  ->setEmail($row->email)
                  ->setComment($row->comment)
                  ->setCreated($row->created)
                  ->setMapper($this); * /
            $entry->setAllFromGenClass($row);      
            $entries[] = $entry;
//            echo " c="+$c++;
        }*/
        return $row;
    }
	
    function fillCache($spare_part_supplier_id ){
		$start = microtime(true);
    	$db=$this->getDbAdapter();
    	$select = $db->select(array('spare_part_price_id','spare_part_supplier_id'));
    	//echo " tableName  ".$this->getDbTableName();
    	//$select->from('spare_part_prices');
    	//s$select->where(' spare_part_supplier_id = ? ',$spare_part_supplier_id);
    	//$o =  $select->query(Zend_Db::FETCH_ASSOC);
    	//$o = $this->getDbTable()->fetchAll(' spare_part_supplier_id = '..' ',);
    	//var_dump($o);
    	//$sql_grp = "SELECT COUNT(*) AS `R�kker`, `spare_part_supplier_id` FROM `spare_part_prices` GROUP BY `spare_part_supplier_id` ORDER BY `spare_part_supplier_id` LIMIT 0, 30 ";
    	$sql = "select * from spare_part_prices where spare_part_supplier_id = $spare_part_supplier_id ";
    	//$sql = $o;
    	$ar = $db->fetchAll($sql);
    	$s1 = microtime(true);
    	$diff_load  =  microtime_diff($start);
    	$p = array();
    	foreach($ar as $key=>$val){
    		//echo "<br/> $key  $val  ".print_r($val);
    		$id = $val['spare_part_price_id'];
    		$p[$id] = $val;
    	}
    	self::$prices[$spare_part_supplier_id];    	
    	$rows = count($ar);
    	$diff_2 =  microtime_diff($s1);
    	echo "<hr>Rows loaded $rows  from supplier id $spare_part_supplier_id ";
    	echo "<br> Load time = $diff_load seconds  ".(1.0*$rows/$diff_load)." rows pr sec ";
    	echo "<br> Foreach time = $diff_2 seconds  ".(1.0*$rows/$diff_2)." rows pr sec ";    	
    }
    
    function fillCacheDirect($spare_part_supplier_id ){
		$start = microtime(true);
    	$mysqli=$this->getDbAdapter()->getConnection();
    	/*die("class_name ".print_r($conn).var_export(get_class_methods(get_class($conn)),true)
    	);*/
    	
    	
    	/*$conn->exec("");
    	$res = mysql_query()
    	$ar = mysql_fetch_assoc()
    	$select = $db->select(array('spare_part_price_id','spare_part_supplier_id'));
    	//echo " tableName  ".$this->getDbTableName();
    	$select->from('spare_part_prices');
    	$select->where(' spare_part_supplier_id = ? ',$spare_part_supplier_id);
    	$o =  $select->query(Zend_Db::FETCH_ASSOC);
    	//$o = $this->getDbTable()->fetchAll(' spare_part_supplier_id = '..' ',);
    	//var_dump($o);
    	$sql_grp = "SELECT COUNT(*) AS `R�kker`, `spare_part_supplier_id` FROM `spare_part_prices` GROUP BY `spare_part_supplier_id` ORDER BY `spare_part_supplier_id` LIMIT 0, 30 ";
    	*/
    	$sql = "select * from spare_part_prices where spare_part_supplier_id = $spare_part_supplier_id ";
    	//$sql = $o;
    	//$ar = $db->fetchAll($sql);
    	//$mysqli = (mysqli)$mysqli;
    	$result = $mysqli->query($sql);
    	$s1 = microtime(true);
    	$diff_load  =  microtime_diff($start);
    	bdp::log("Number of SparePartPrices (DB rows before parse) ".$rows=$result->num_rows.' <br> ');
        if ($result) {
            while ($row = $result->fetch_assoc()) {
	            $id = $row['supplier_part_number'];
	    		self::$prices_from_current_supplier[$id] = $row;
	            /* Commented out for memory usage
	            $spp_id = $row['spare_part_supplier_id'];
	    		self::$prices[$spp_id][$id] = $row;
	    		*/
            }
            $result->close();
        }
		else{
			error("sql:<br>$sql<br>No result".$mysqli->error.$mysqli->sqlstate);	
		}
		
		if(bdp::$_log_obj){  	
    	$diff_2 =  microtime_diff($s1);
    		bdp::log("SPPM: Direct Rows loaded $rows  from supplier id $spare_part_supplier_id ");
    		bdp::log(" Load time = $diff_load seconds  ".(1.0*$rows/$diff_load)." rows pr sec ");
    		bdp::log(" Foreach time = $diff_2 seconds  ".(1.0*$rows/$diff_2)." rows pr sec ");    
		}	
    }

    function fillCacheAll(){
    	self::$prices = array();
		$start = microtime(true);
    	$db=$this->getDbAdapter();
    	$select = $db->select(array('spare_part_price_id','spare_part_supplier_id'));
    	//echo " tableName  ".$this->getDbTableName();
    	$select->from('spare_part_prices');
    	//$select->where(' spare_part_supplier_id = ? ',$spare_part_supplier_id);
    	//$o =  $select->query(Zend_Db::FETCH_ASSOC);
    	//$o = $this->getDbTable()->fetchAll(' spare_part_supplier_id = '..' ',);
    	//var_dump($o);
    	$sql_grp = "SELECT COUNT(*) AS `Rækker`, `spare_part_supplier_id` FROM `spare_part_prices` GROUP BY `spare_part_supplier_id` ORDER BY `spare_part_supplier_id` LIMIT 0, 30 ";
    	$sql = "select * from spare_part_prices ";
    	//$sql = $o;
    	$ar = $db->fetchAll($sql);
    	$s1 = microtime(true);
    	$diff_load  =  microtime_diff($start);
    	$p = array();
    	foreach($ar as /*$key=>*/$val){
    		// "<br/> $key  $val  ".print_r($val);
    		$id = $val['spare_part_price_id'];
    		$spp_id = $val['spare_part_supplier_id'];
    		//$p[$id] = $val;
    		self::$prices[$spp_id][$id] = $val;
    	}
    	//self::$prices[$spare_part_supplier_id];    	
    	$rows = count($ar);
    	$diff_2 =  microtime_diff($s1);
    	bdp::log("FA: All rows loaded $rows  from all suppliers ");
    	bdp::log("Load time = $diff_load seconds  ".(1.0*$rows/$diff_load)." rows pr sec ");
    	bdp::log("Foreach time = $diff_2 seconds  ".(1.0*$rows/$diff_2)." rows pr sec ");    	
    }
    

}

